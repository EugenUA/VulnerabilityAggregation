package service.vulnerabilities_aggregation.Classification;

import entities.programEntities.miningEntities.PreprocessingEntity;
import service.vulnerabilities_aggregation.Clustering.CosineSimilarity;
import service.vulnerabilities_aggregation.Clustering.EuclideanDistance;

import java.util.ArrayList;
import java.util.List;

public class Classification {

    private ArrayList<PreprocessingEntity> preprocessingEntities;

    public Classification(ArrayList<PreprocessingEntity> preprocessingEntities1){
        this.preprocessingEntities=preprocessingEntities1;
    }

    /* CREATE VECTOR SPACE MODEL */

    /* SHORT description */
    private List<String[]> short_description_array = new ArrayList<String[]>(); // all terms of each document
    private List<String> short_description_allTerms = new ArrayList<String>(); // all terms of all documents

    private List<double[]> short_tfidfDocsVector = new ArrayList<double[]>();

    /* LONG description*/
    private List<String[]> long_description_array = new ArrayList<String[]>(); // all terms of each document
    private List<String> long_description_allTerms = new ArrayList<String>(); // all terms of all documents

    private List<double[]> long_tfidfDocsVector = new ArrayList<double[]>();

    public void tfIdfClaculator_SHORT(){
        for(PreprocessingEntity preprocessingEntity : preprocessingEntities){
            short_description_array.add(preprocessingEntity.getPreprocessedShortDescription().toArray(new String[0]));
        }

        for(String[] str : short_description_array){
            for(int i = 0; i < str.length; i++){
                if(!short_description_allTerms.contains(str[i])){
                    short_description_allTerms.add(str[i]);
                }
            }
        }

        double tf;
        double idf;
        double tfidf;
        for (String[] docTermsArray : short_description_array) {
            double[] tfidfvectors = new double[short_description_allTerms.size()];
            int count = 0;
            for (String terms : short_description_allTerms) {
                tf = new TfIdf().tfCalculator(docTermsArray, terms);
                idf = new TfIdf().idfCalculator(short_description_array, terms);
                tfidf = tf * idf;
                tfidfvectors[count] = tfidf;
                count++;
            }
            short_tfidfDocsVector.add(tfidfvectors);  //storing document vectors;
        }

       /* for(double[] db : short_tfidfDocsVector){
            for(int i = 0; i < db.length; i++){
                System.out.print(db[i] + " ");
            }
            System.out.println();
        }*/
    }

    public void tfIdfClaculator_LONG(){
        for(PreprocessingEntity preprocessingEntity : preprocessingEntities){
            long_description_array.add(preprocessingEntity.getPreprocessedLongDescription().toArray(new String[0]));
        }

        for(String[] str : long_description_array){
            for(int i = 0; i < str.length; i++){
                if(!long_description_allTerms.contains(str[i])){
                    long_description_allTerms.add(str[i]);
                }
            }
        }

        double tf;
        double idf;
        double tfidf;
        for (String[] docTermsArray : long_description_array) {
            double[] tfidfvectors = new double[long_description_allTerms.size()];
            int count = 0;
            for (String terms : long_description_allTerms) {
                tf = new TfIdf().tfCalculator(docTermsArray, terms);
                idf = new TfIdf().idfCalculator(long_description_array, terms);
                tfidf = tf * idf;
                tfidfvectors[count] = tfidf;
                count++;
            }
            long_tfidfDocsVector.add(tfidfvectors);  //storing document vectors;
        }

        /*for(double[] db : long_tfidfDocsVector){
            System.out.println(db.length);
        }*/
    }

    //Test
    public void getCosineSimilarity() {
        for (int i = 0; i < long_tfidfDocsVector.size(); i++)
        {
            for (int j = 0; j < long_tfidfDocsVector.size(); j++)
            {
                if(i!=j)
                    System.out.println("between " + i + " and " + j + "  =  "+ new CosineSimilarity().cosineSimilarity (
                            long_tfidfDocsVector.get(i),  long_tfidfDocsVector.get(j)));
            }
        }
    }


    /* CONDUCT CLASSIFICATION */

}
